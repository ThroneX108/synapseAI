# 1. Enums
enum UserRole {
  STUDENT
  COUNSELOR
}

enum AppointmentStatus {
  AVAILABLE
  PENDING     # Requested by student, waiting for approval
  CONFIRMED   # Approved
  COMPLETED
  CANCELLED
  BLOCKED
}

enum ResourceType {
  VIDEO
  ARTICLE
}

# 2. Base User Profile (Authentication Hub)
type UserProfile
@model
@auth(rules: [
  { allow: owner },
  { allow: private, operations: [read] } # Allows search/lookup for counselors/students
]) {
  id: ID!
  name: String!
  role: UserRole!
  imageUrl: String
  phoneNumber: String

  # Navigation links to specific profiles
  studentProfile: StudentProfile @hasOne
  counselorProfile: CounselorProfile @hasOne

  # Chat Relationship
  chatRooms: [ChatRoomUser] @hasMany(indexName: "byUser", fields: ["id"])
}

# 3. Student Specific Data
type StudentProfile
@model
@auth(rules: [
  { allow: owner },
  { allow: private, operations: [read] }
]) {
  id: ID!
  userProfileID: ID!

  # ✅ LINKED: Fetch Name/Image from UserProfile directly
  user: UserProfile @belongsTo(fields: ["userProfileID"])

  # Academic Details
  branch: String
  year: String

  # Dashboard Stats
  wellnessScore: Int
  currentMood: String

  # Relationships
  moodLogs: [MoodLog] @hasMany(indexName: "byStudent", fields: ["id"])
  appointments: [Appointment] @hasMany(indexName: "byStudent", fields: ["id"])
}

# 4. Counselor Specific Data
type CounselorProfile
@model
@auth(rules: [
  { allow: owner },
  { allow: private, operations: [read] } # Students need to read this to book
]) {
  id: ID!
  userProfileID: ID!

  # ✅ LINKED: Fetch Name/Image from UserProfile
  user: UserProfile @belongsTo(fields: ["userProfileID"])

  # Professional Details
  specialization: String!
  experienceYears: Int
  rating: Float
  aboutMe: String
  languages: [String]

  # Profile Details
  licenseNumber: String
  fee: Float
  isVerified: Boolean

  # Dashboard Status
  isOnline: Boolean

  # Relationships
  appointments: [Appointment] @hasMany(indexName: "byCounselor", fields: ["id"])
}

# 5. Appointments & Requests
type Appointment
@model
@auth(rules: [
 { allow: owner }, # Creator (Counselor)
     { allow: owner, ownerField: "counselorID", operations: [read, update] },
     # ✅ ADD 1: Once booked, the Student owns this record too
     { allow: owner, ownerField: "studentID", operations: [read, update] },
     # ✅ ADD 2: Allow 'update' so Students can claim an Available slot
     { allow: private, operations: [read, update] }
]) {
  id: ID!
  studentID: ID! @index(name: "byStudent", sortKeyFields: ["date"])
  student: StudentProfile @belongsTo(fields: ["studentID"])
  counselorID: ID! @index(name: "byCounselor", sortKeyFields: ["date"])
  counselor: CounselorProfile @belongsTo(fields: ["counselorID"])
  date: AWSDate!
  timeSlot: String!
  status: AppointmentStatus!
  topic: String
  meetingLink: String
  counselorNotes: String
}

# 6. Chat System (Human-to-Human)
type ChatRoom
@model
@auth(rules: [{ allow: private }]) {
  id: ID!
  users: [ChatRoomUser] @hasMany(indexName: "byChatRoom", fields: ["id"])
  messages: [Message] @hasMany(indexName: "byChatRoom", fields: ["id"])

  # For List View Performance
  lastMessageContent: String
  lastMessageTime: AWSDateTime
}

type ChatRoomUser
@model
@auth(rules: [{ allow: private }]) {
  id: ID!
  userID: ID! @index(name: "byUser")
  chatRoomID: ID! @index(name: "byChatRoom")

  user: UserProfile @belongsTo(fields: ["userID"])
  chatRoom: ChatRoom @belongsTo(fields: ["chatRoomID"])

  unreadCount: Int
}

type Message
@model
@auth(rules: [{ allow: private }]) {
  id: ID!
  chatRoomID: ID! @index(name: "byChatRoom", sortKeyFields: ["createdAt"])
  senderID: ID!
  content: String!
  createdAt: AWSDateTime!
  isRead: Boolean
}

# 7. Dashboard Charts (Moods)
type MoodLog
@model
@auth(rules: [{ allow: owner }]) {
  id: ID!
  studentID: ID! @index(name: "byStudent", sortKeyFields: ["date"])
  date: AWSDate!
  score: Int!
  moodLabel: String
  sleepHours: Float
  focusHours: Float
}

# 8. Resources (Content Library)
type Resource
@model
@auth(rules: [
  { allow: private, operations: [read] },
  { allow: groups, groups: ["Admin"], operations: [create, update, delete] }
]) {
  id: ID!
  title: String!
  type: ResourceType!
  category: String!
  duration: String
  description: String
  contentBody: String
  url: String
  thumbnailUrl: String
  isFeatured: Boolean
}

# 9. AI Chat History (Gemini Chat)
type AIChatSession
@model
@auth(rules: [{ allow: owner }]) {
  id: ID!
  title: String!

  messages: [AIChatMessage] @hasMany(indexName: "bySession", fields: ["id"])

  # Explicit fields for Dart model generation
  updatedAt: AWSDateTime
  createdAt: AWSDateTime
}

type AIChatMessage
@model
@auth(rules: [{ allow: owner }]) {
  id: ID!
  sessionID: ID! @index(name: "bySession", sortKeyFields: ["createdAt"])

  content: String!
  isUser: Boolean!

  # Explicit fields for Dart model generation
  createdAt: AWSDateTime!
}
